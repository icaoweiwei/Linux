每一个文件都会有所谓的拥有者ID与拥有群组ID，当我们有要显示文件属性的需求时，系统会依据 /etc/passwd 与 /etc/group 的内容， 找到 UID / GID 对应的账号与组名再显示出来！

# /etc/passwd 文件结构
每一行都代表一个账号，有几行就代表有几个账号在你的系统中！ 不过需要特别留意的是，里头很多账号本来就是系统正常运行所必须要的，我们可以简称他为系统账号， 例如 bin, daemon, adm, nobody 等等，这些账号请不要随意的杀掉他呢！ 

```
[root@www ~]# head -n 4 /etc/passwd
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
```
1. 账号名称：就是账号啦！用来对应 UID 的。例如 root 的 UID 对应就是 0 (第三字段)。
1. 口令：早期 Unix 系统的口令就是放在这字段上！但是因为这个文件的特性是所有的程序都能够读取，这样一来很容易造成口令数据被窃取， 因此后来就将这个字段的口令数据给他改放到 /etc/shadow 中了。所以这里你会看到一个“x”！
1. UID：这个就是使用者标识符啰！通常 Linux 对于 UID 有几个限制需要说给您了解一下：0(系统管理员)、1\~499(系统账号)、500\~65535(可登陆账号)。
1. GID：这个与 /etc/group 有关！其实 /etc/group 的观念与 /etc/passwd 差不多，只是他是用来规范组名与 GID 的对应而已！
1. 用户信息说明栏：这个字段基本上并没有什么重要用途，只是用来解释这个账号的意义而已！不过，如果您提供使用 finger 的功能时， 这个字段可以提供很多的信息呢！
1. 家目录：这是用户的家目录，以上面为例， root 的家目录在 /root ，所以当 root 登陆之后，就会立刻跑到 /root 目录里头啦！呵呵！ 如果你有个账号的使用空间特别的大，你想要将该账号的家目录移动到其他的硬盘去该怎么作？ 没有错！可以在这个字段进行修改呦！默认的用户家目录在 /home/yourIDname
1. Shell：当用户登陆系统后就会取得一个 Shell 来与系统的核心沟通以进行用户的操作任务。那为何默认 shell 会使用 bash 呢？就是在这个字段指定的啰！这里比较需要注意的是，有一个 shell 可以用来替代成让账号无法取得 shell 环境的登陆动作！那就是 /sbin/nologin 这个东西！这也可以用来制作纯 pop 邮件账号者的数据呢！

# /etc/shadow 文件结构
```
[root@www ~]# head -n 4 /etc/shadow
root:$1$/30QpE5e$y9N/D0bh6rAACBEz.hqo00:14126:0:99999:7:::
bin:*:14126:0:99999:7:::
daemon:*:14126:0:99999:7:::
adm:*:14126:0:99999:7:::
```
1. 账号名称：由于口令也需要与账号对应啊～因此，这个文件的第一栏就是账号，必须要与 /etc/passwd 相同才行！
1. 口令：这个字段内的数据才是真正的口令，而且是经过编码的口令 (加密) 啦！这个文件的默认权限是`-rw-------`或者是`-r--------`，亦即只有 root 才可以读写就是了！
1. 最近变更口令的日期：这个字段记录了『变更口令那一天』的日期，不过，很奇怪呀！在我的例子中怎么会是 14126 呢？呵呵，这个是因为计算 Linux 日期的时间是以 1970 年 1 月 1 日作为 1 而累加的日期，1971 年 1 月 1 日则为 366 啦！ 得注意一下这个数据呦！上述的 14126 指的就是 2008-09-04 那一天啦！想要知道某个日期的累积日数， 可使用如下的程序计算：`echo $(($(date --date="2008/09/04" +%s)/86400+1))`，上述命令中，2008/09/04 为你想要计算的日期，86400 为每一天的秒数， %s 为 1970/01/01 以来的累积总秒数。 由于 bash 仅支持整数，因此最终需要加上 1 补齐 1970/01/01 当天。
1. 口令不可被变更的天数：(与第 3 字段相比)第四个字段记录了：这个账号的口令在最近一次被更改后需要经过几天才可以再被变更！如果是 0 的话，表示口令随时可以变更的意思。这的限制是为了怕口令被某些人一改再改而设计的！如果配置为 20 天的话，那么当你配置了口令之后， 20 天之内都无法改变这个口令呦！
1. 口令需要重新变更的天数：(与第 3 字段相比)经常变更口令是个好习惯！为了强制要求用户变更口令，这个字段可以指定在最近一次更改口令后， 在多少天数内需要再次的变更口令才行。你必须要在这个天数内重新配置你的口令，否则这个账号的口令将会“变为过期特性”。 而如果像上面的 99999 (计算为 273 年) 的话，那就表示，呵呵，口令的变更没有强制性之意。
1. 口令需要变更期限前的警告天数：(与第 5 字段相比)当账号的口令有效期限快要到的时候 (第 5 字段)，系统会依据这个字段的配置，发出“警告”言论给这个账号，提醒他“再过 n 天你的口令就要过期了，请尽快重新配置你的口令呦！”，如上面的例子，则是口令到期之前的 7 天之内，系统会警告该用户。
1. 口令过期后的账号宽限时间(口令失效日)：(与第 5 字段相比)口令有效日期为“升级日期(第3字段)”+“重新变更日期(第5字段)”，过了该期限后用户依旧没有升级口令，那该口令就算过期了。 虽然口令过期但是该账号还是可以用来进行其他工作的，包括登陆系统取得 bash 。不过如果口令过期了， 那当你登陆系统时，系统会强制要求你必须要重新配置口令才能登陆继续使用喔，这就是口令过期特性。那这个字段的功能是什么呢？是在口令过期几天后，如果使用者还是没有登陆更改口令，那么这个账号的口令将会“失效”， 亦即该账号再也无法使用该口令登陆了。要注意口令过期与口令失效并不相同。
1. 账号失效日期：这个日期跟第三个字段一样，都是使用 1970 年以来的总日数配置。这个字段表示： 这个账号在此字段规定的日期之后，将无法再使用。 就是所谓的“账号失效”，此时不论你的口令是否有过期，这个“账号”都不能再被使用！ 这个字段会被使用通常应该是在“收费服务”的系统中，你可以规定一个日期让该账号不能再使用啦！
1. 保留：最后一个字段是保留的，看以后有没有新功能加入。
